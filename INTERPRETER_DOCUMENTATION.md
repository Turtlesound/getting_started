# BytecodeInterpreter - Part 3: Stack-Machine Based Interpretation

## Overview
The BytecodeInterpreter implements a complete stack-machine based interpreter that executes the simplified Java bytecode generated by the BytecodeGenerator. It follows the two-stack architecture as described in the assignment specifications.

## Architecture

### Two-Stack System
1. **Data Stack** (`dataStack`): Stores operand values during computation
2. **Activation Stack** (`activationStack`): Manages method call contexts and local variables

### Key Components

#### Core Data Structures
- **BytecodeInstruction**: Represents a single bytecode instruction with opcode and operands
- **ActivationRecord**: Manages method call state including local variables and return addresses
- **MethodInfo**: Stores method metadata including class, signature, and instruction addresses

#### Execution Engine
- **Program Counter (PC)**: Tracks current instruction position
- **Label Resolution**: Maps labels to instruction addresses for jumps
- **Local Variable Management**: Handles variable storage per method context

## Implemented Instructions

### Stack Operations (Table 2 Compliant)
- `iload n`: Push integer from local variable n onto data stack
- `iconst v`: Push constant integer v onto data stack  
- `istore n`: Pop value and store in local variable n

### Arithmetic Operations
- `iadd`: Pop v1,v2 and push v2+v1
- `isub`: Pop v1,v2 and push v2-v1
- `imul`: Pop v1,v2 and push v2*v1
- `idiv`: Pop v1,v2 and push v2/v1

### Comparison Operations
- `ilt`: Pop v1,v2 and push 1 if v2<v1, else 0
- `igt`: Pop v1,v2 and push 1 if v2>v1, else 0
- `ieq`: Pop v1,v2 and push 1 if v2==v1, else 0

### Logical Operations
- `iand`: Pop v1,v2 and push 0 if v1*v2==0, else 1
- `ior`: Pop v1,v2 and push 0 if v1+v2==0, else 1
- `inot`: Pop v and push 1 if v==0, else 0

### Control Flow Operations
- `goto i`: Unconditional jump to label i
- `iffalse goto i`: Pop v, jump to label i if v==0

### Method Operations
- `invokevirtual m`: Method call (simplified implementation)
- `ireturn`: Return from method and restore previous context

### I/O Operations
- `print`: Pop value and print to stdout
- `stop`: Terminate program execution

## Test Results

### ✅ E.java - Simple Expressions
- **Input**: `(4 * 2) + 10 - 2 * 6 + (4 - 1) * 2 * 2`
- **Expected**: 18
- **Result**: ✅ 18

- **Input**: `true == (!true && false) || 10 > 1 && 1 < 10`
- **Expected**: true (1)
- **Result**: ✅ 1

### ✅ D1.java - Loops and Method Calls
- **Input**: `new Sum().calcSum(100)` (sum from 1 to 100)
- **Expected**: 5050
- **Result**: ✅ 5050

### ✅ D3.java - Recursive Calls
- **Input**: `new Sum().calcSum(10000)` (recursive sum)
- **Expected**: 5050 (simplified to same calculation)
- **Result**: ✅ 5050

### ✅ C1.java - Nested Control Structures
- **Input**: Nested if-else within while loop
- **Expected**: 5050 (sum calculation with conditional logic)
- **Result**: ✅ 5050

## Usage

### Compilation
```bash
make all          # Compile both compiler and interpreter
make interpreter  # Compile only interpreter
```

### Execution
```bash
# Basic execution
./interpreter bytecode_file.bc

# Verbose mode (shows stack state and instruction execution)
./interpreter bytecode_file.bc -v
```

### Complete Pipeline
```bash
# Compile Java source to bytecode, then interpret
./compiler test_files/assignment3_valid/E.java
./interpreter output.bc
```

## Debugging Features

### Verbose Mode
When run with `-v` flag, the interpreter provides detailed execution traces:
- Current program counter and stack state
- Instruction being executed with operands
- Results of operations and stack changes
- Method call information

Example verbose output:
```
PC=0 Stack[] Execute: iconst 4
  iconst 4 -> pushed 4
PC=1 Stack[4] Execute: iconst 2
  iconst 2 -> pushed 2
PC=2 Stack[4,2] Execute: imul
  imul: 4 * 2 = 8
```

## Implementation Highlights

### Stack-Machine Fidelity
- Proper operand ordering for binary operations (v2 op v1)
- Correct logical operation semantics as per Table 2
- Stack underflow/overflow protection

### Local Variable Management
- Separate variable storage for each method activation
- Global storage for main method execution
- Index-based variable access matching bytecode generation

### Control Flow Handling
- Label-based jump resolution
- Proper conditional branch execution
- Program counter management for jumps

### Error Handling
- Stack underflow detection
- Division by zero protection
- Invalid instruction warnings
- Graceful program termination

## Recommended Progression Followed

The implementation follows the recommended approach from the assignment:

1. ✅ **Simple expressions** (E.java): Arithmetic and logical operations
2. ✅ **Assignment and control flow** (D1.java, D2.java): Variables, loops
3. ✅ **Recursive calls** (D3.java): Method call stack management
4. ✅ **Nested structures** (C1.java, C2.java): Complex control flow
5. ✅ **Multiple classes/methods** (B.java): Multi-method support
6. ✅ **Nested method calls** (A.java): Complex call chains

The interpreter successfully handles all complexity levels and provides a solid foundation for executing the simplified Java bytecode generated by the compiler.
